open Lang
open Vlang
open Z3Interface
open Vocab
open Options
open Query
open Path
open Semantics
open ExploitReport
open Transaction
open ExecTran

(******************************)
(******************************)
(*** Quantifier Elimination ***)
(******************************)
(******************************)

let rec addrs_vf : var -> int -> vformula -> vexp list
= fun x dim vf ->
  match vf with
  | VTrue | VFalse -> []
  | VNot f -> addrs_vf x dim f
  | VAnd (f1,f2) -> (addrs_vf x dim f1) @ (addrs_vf x dim f2)
  | VOr (f1,f2) -> (addrs_vf x dim f1) @ (addrs_vf x dim f2)
  | VBinRel (_,e1,e2) -> (addrs_ve x dim e1) @ (addrs_ve x dim e2)
  | Imply (f1,f2) -> (addrs_vf x dim f1) @ (addrs_vf x dim f2)
  | SigmaEqual _ | NoOverFlow _ | UntrustSum _ | UntrustSum2 _ -> assert false
  | ForAll _ -> []
  | Label (_,f) -> addrs_vf x dim f

and addrs_ve : var -> int -> vexp -> vexp list
= fun x dim ve ->
  match ve with
  | VInt _ | VVar _ -> []
  | Read (VVar y, e2) (* y[e2] *)
    when dim=1 && BatString.equal (fst (org x)) (fst (org y)) ->
    [e2]
  | Read (Read (VVar y, e1), e2) (* y[e1][e2] *)
    when dim=2 && BatString.equal (fst (org x)) (fst (org y)) ->
    [e1;e2]
  | Read (e1,e2) -> (addrs_ve x dim e1) @ (addrs_ve x dim e2)
  | Write (VVar y, e2, e3) (* y[e2] := e3 *)
    when dim=1 && BatString.equal (fst (org x)) (fst (org y)) ->
    [e2] @ (addrs_ve x dim e3)
  | Write (VVar y1, i, Write (Read (VVar y2, i'), j, e))
    (* y[i][j] := e => y = write (y', i, write (y'[i],j,e))  *)
    when dim=2 && BatString.equal (fst (org x)) (fst (org y1)) && BatString.equal (fst (org y1)) (fst (org y2)) ->
    let _ = assert (equal_ve i i') in
    [i;j] @ (addrs_ve x dim e)
  | Write (e1,e2,e3) -> (addrs_ve x dim e1) @ (addrs_ve x dim e2) @ (addrs_ve x dim e3)
  | VBinOp (_,e1,e2,_) -> (addrs_ve x dim e1) @ (addrs_ve x dim e2)
  | VUnOp (_,e,_) -> addrs_ve x dim e
  | VCast (_,e) -> addrs_ve x dim e
  | VCond f -> addrs_vf x dim f
  | Ite (e1,e2,e3) -> (addrs_ve x dim e1) @ (addrs_ve x dim e2) @ (addrs_ve x dim e3)
  | Uninterp _ -> raise NotImplemented


let rec qe_f : vformula -> vformula -> vformula
= fun whole vf ->
  match vf with
  | VTrue | VFalse -> vf
  | VNot f -> VNot (qe_f whole f)
  | VAnd (f1,f2) -> VAnd (qe_f whole f1, qe_f whole f2)
  | VOr (f1,f2) -> VOr (qe_f whole f1, qe_f whole f2)
  | VBinRel (brel,e1,e2) -> vf
  | Imply (f1,f2) -> Imply (qe_f whole f1, qe_f whole f2)
  | SigmaEqual _ | NoOverFlow _ | UntrustSum _ | UntrustSum2 _ -> assert false
  | ForAll ([i],VBinRel (VEq, Read (VVar x, VVar i'), e)) when is_mapping (snd x) ->
    let _ = assert (i=i') in
    let addrs = addrs_vf x 1 whole in
    let addrs = List.sort_uniq compare_ve addrs in
    List.fold_left (fun acc p ->
      let f = VBinRel (VEq, Read (VVar x, p), e) in
      if equal_vf acc VTrue then f
      else VAnd (acc, f)
    ) VTrue addrs
  | ForAll ([i;j],VBinRel (VEq, Read (Read (VVar x,VVar i'), VVar j'), e)) when is_mapping (snd x) ->
    let _ = assert (i=i' && j=j') in
    let addrs = addrs_vf x 2 whole in
    let rec get_pairs lst =
      (match lst with
       | [] -> []
       | (h1::h2::tl) -> [(h1,h2)] @ (get_pairs tl)
       | _ -> failwith "qe_f : get_pairs") in
    let addr_pairs = get_pairs addrs in
    let compare_pair (a,a') (b,b') =
      let res = compare_ve a b in
      if res = 0 then compare_ve a' b' else res in
    let addr_pairs = List.sort_uniq compare_pair addr_pairs in 
    List.fold_left (fun acc (p,q) ->
      let f = VBinRel (VEq, Read (Read (VVar x, p), q), e) in
      if equal_vf acc VTrue then f
      else VAnd (acc, f) 
    ) VTrue addr_pairs
  | ForAll (_,VTrue) ->
    (* this case may appear when constraints are invalidated by
     * assembly block or function calls that are not inlined. *)
    vf
  | ForAll _ -> vf
    (* failwith ("qe_f (ForAll) : " ^ to_string_vformula vf) *)
  | Label (l,f) -> Label (l, qe_f whole f)

let quantifier_elimination vf = qe_f vf vf

let sat_wrapper: vformula -> int * Z3.Model.model option
= fun f -> Z3Interface.is_sat f

let debug global tseq dep_vars vc vc_opt vc_qe vc_pow vc_sim =
  if BatString.equal !Options.debug "formula" then
    (prerr_endline "=== sequence ===";
     prerr_endline (to_string_transactions_simple global tseq);
     prerr_endline "=== dependant variables ===";
     prerr_endline (string_of_set (fst |> id) dep_vars);
     prerr_endline "=== initial ===";
     prerr_endline (to_string_vformula vc);
     prerr_endline "=== after sparsified ===";
     prerr_endline (to_string_vformula vc_opt);
     prerr_endline "=== after quantifier elimination ===";
     prerr_endline (to_string_vformula vc_qe);
     prerr_endline "=== after removing power ===";
     prerr_endline (to_string_vformula vc_pow);
     prerr_endline "=== after simplified ===";
     prerr_endline (to_string_vformula vc_sim);
     prerr_endline "")

let simplify : Global.t -> transaction list -> vformula -> vformula
= fun global tseq vc ->
  let (pgm_const,safety) = match vc with VAnd (f1, VNot f2) -> (f1,f2) | _ -> assert false in
  let dep_vars = Opt.compute_dependant_vars pgm_const safety in
  let vc_opt = Opt.remove_unrelated_part dep_vars vc in
  let _ = assert (not (has_label vc_opt)) in
  let vc_qe = quantifier_elimination vc_opt in
  let vc_pow = Simplification.remove_pow vc_qe in
  let vc_sim = Simplification.fix Simplification.normalize vc_pow in
  let _ = debug global tseq dep_vars vc vc_opt vc_qe vc_pow vc_sim in
  vc_sim

let violation_found : query -> QMap.t -> bool
= fun q qmap ->
  let v = QMap.find (QMap.mk_key q) qmap in
  v.stat = Disproven

let choose_final_vc : query -> vformula
= fun q ->
  if !Options.refined_vcgen then
    match q.kind with
    | IO -> q.vc2
    | DZ -> q.vc
    | ASSERT -> q.vc
    | KILL -> q.vc
    | ETH_LEAK ->
      (match q.org_q with
       | Org_Stmt (Call (lvop,Lv (Var (fname,_)),args,_,_,loc))
         when List.mem fname ["selfdestruct";"suicide"] -> q.vc
       | Org_Stmt (Call (lvop,Lv (MemberAccess (e,fname,_,_)),args,_,_,loc))
         when is_address_kind (get_type_exp e) && List.mem fname ["transfer";"send"] -> q.vc2
       | Org_Stmt (Call (lvop, Lv (MemberAccess (e,"call",_,_)), args, Some eth, gasop, loc))
         when is_address_kind (get_type_exp e) -> q.vc2
       | _ -> assert false)
    | ERC20 -> q.vc
    | RE_EL ->
      (* let _ = print_endline "" in
      let  _ = print_endline (Path.to_string q.path) in
      let _ = print_endline (to_string_vformula q.vc) in
      let _ = print_endline (to_string_vformula q.vc2) in *)
      q.vc2
    | RE | TX_ORG | COV | NO_EFFECT | ASSIGN_CONST | DEAD -> failwith "NotImplemented"
  else q.vc

let inspect_queries : Global.t -> transaction list -> query list -> QMap.t -> QMap.t
= fun global tseq queries qmap ->
  List.fold_left (fun acc q ->
    if (Sys.time () -. !Profiler.start_cpu) > float_of_int !Options.exploit_timeout then acc
    else if violation_found q acc then acc
    else
      let vc = choose_final_vc q in
      let (pgm_const,safety) = split_implication vc in
      let vc = VAnd (pgm_const, VNot safety) in
      let vc_sim = simplify global tseq vc  in
      let (signal,mop) = sat_wrapper vc_sim in
      let _ = formula_cnt := !formula_cnt + 1 in
      let _ = if signal=2 then timeout_cnt := !timeout_cnt + 1 in
      if signal=1 then
        (if BatString.equal !Options.debug "success" then
          prerr_endline (to_string_tseq global tseq); (* ^ " : " ^ string_of_float prob ^ "," ^ string_of_float (exp (-. prob))); *)
          last_disproven_iter := !iter;
          last_disproven_time := Sys.time () -. !Profiler.start_cpu;
          max_disproven_depth := max !max_disproven_depth (List.length tseq - 1);
          (* print_endline (to_string_vformula vc);
           print_endline (to_string_vformula vc_sim);
           print_endline (Z3.Model.to_string (remove_some mop));
           print_endline (Path.to_string q.path); *)
         let qv =
           {stat = Disproven; tseq = tseq; mop=mop; vc=vc; sc_src=q.sc_src; attacker_src=q.attacker_src;
            time = Sys.time() -. !Profiler.start_cpu; eth_src=q.eth_src;
            validated = false}
         in
         QMap.add (QMap.mk_key q) qv acc)
      else acc
  ) qmap queries

module Workset = struct
  type elem = float * transaction list

  module OrderedType = struct
    type t = elem
    let compare (cost1,_) (cost2,_) = Stdlib.compare cost1 cost2
  end

  module Heap = BatHeap.Make (OrderedType)

  type t = Heap.t

  let empty = Heap.empty

  let pick_min : t -> elem option
  = fun heap -> 
    try Some (Heap.find_min heap)
    with _ -> None

  let remove_min : t -> t
  = fun heap ->  Heap.del_min heap

  let add : t -> elem -> t
  = fun heap work -> Heap.add work heap

  let workset_info : t -> string
  = fun heap -> "# of Workset Elements : " ^ string_of_int (Heap.size heap)
end

let tseq_contain_extern_log : Global.t -> transaction list -> bool
= fun global tseq ->
  List.exists (fun (tid,path) ->
    let f = FuncMap.find (Path.get_fkey path) global.fmap in
    let g = get_cfg f in
    let nodes = Path.get_bp path in
    List.exists (fun n -> is_extern_log_node n g) nodes
  ) tseq
