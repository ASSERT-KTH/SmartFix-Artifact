open Lang
open Vocab
open Query

(****************************************)
(*** Features for path representation ***)
(****************************************)

type feature = {
  def_simple : bool;
  def_other  : bool;
  use_simple : bool;
  use_other  : bool;
  use_of_prev_def_simple : bool;
  use_of_prev_def_other : bool;
  invoked_before : bool;
}

let empty_feature = {
  def_simple = false;
  def_other = false;
  use_simple = false;
  use_other = false;
  use_of_prev_def_simple = false;
  use_of_prev_def_other = false;
  invoked_before = false;
}

let string_of_feature feat =
  let b2i b = if b then "1" else "0" in
  "[" ^
  b2i feat.def_simple ^
  b2i feat.def_other ^
  b2i feat.use_simple ^
  b2i feat.use_other ^
  b2i feat.use_of_prev_def_simple ^
  b2i feat.use_of_prev_def_other ^
  b2i feat.invoked_before ^
  "]"

let vector_of feat =
  let b2i b = if b then 1 else 0 in
  [b2i feat.def_simple;
   b2i feat.def_other;
   b2i feat.use_simple;
   b2i feat.use_other;
   b2i feat.use_of_prev_def_simple;
   b2i feat.use_of_prev_def_other;
   b2i feat.invoked_before
  ]

let rec simplify : exp -> exp
= fun exp ->
  match exp with
  | UnOp (_,e,_) -> simplify e
  | _ -> exp

let def_simple : exp -> bool
= fun exp ->
  match simplify exp with
  | BinOp _ -> false
  | _ -> true

let def_other : exp -> bool
= fun exp ->
  match simplify exp with
  | BinOp _ -> true
  | _ -> false

let use_simple : exp -> bool
= fun exp ->
  match simplify exp with
  | BinOp (bop,_,_,_) when bop=Eq || bop=NEq -> true
  | _ -> false

let use_other : exp -> bool
= fun exp ->
  match simplify exp with
  | BinOp (bop,_,_,_) when not (bop=Eq || bop=NEq) -> true
  | _ -> false

let use_of_prev_def_simple : var BatSet.t -> exp -> bool
= fun simple_defs exp ->
  not (BatSet.disjoint simple_defs (var_exp exp))

let use_of_prev_def_other : var BatSet.t -> exp -> bool
= fun other_defs exp ->
  not (BatSet.disjoint other_defs (var_exp exp))

let invoked_before : Path.t list -> Path.t -> bool
= fun hist cur ->
  let cur_nodes = Path.get_bp cur in
  List.exists (fun past_path ->
    let past_nodes = Path.get_bp past_path in
    past_nodes = cur_nodes
  ) hist

let add_def_simple : feature -> feature
= fun feat -> {feat with def_simple = true}

let add_def_other : feature -> feature
= fun feat -> {feat with def_other = true}

let add_use_simple : feature -> feature
= fun feat -> {feat with use_simple = true}

let add_use_other : feature -> feature
= fun feat -> {feat with use_other = true}

let add_use_of_prev_def_simple : feature -> feature
= fun feat -> {feat with use_of_prev_def_simple = true}

let add_use_of_prev_def_other : feature -> feature
= fun feat -> {feat with use_of_prev_def_other = true}

let add_invoked_before : feature -> feature
= fun feat -> {feat with invoked_before = true}

let rec def_of : lv -> var BatSet.t
= fun lv ->
  match lv with
  | Var (v,vinfo) -> BatSet.singleton (v, vinfo.vtyp)
  | MemberAccess (e,x,xinfo,_) -> BatSet.singleton (x, xinfo.vtyp)
  | IndexAccess (Lv lv,_,_) -> def_of lv
  | IndexAccess (Cast (_, Lv lv),_,_) -> def_of lv
  | Tuple (eops,_) ->
    List.fold_left (fun acc eop ->
      match eop with
      | Some (Lv lv) -> BatSet.union (def_of lv) acc
      | None -> acc
      | _ -> failwith "def_of"
    ) BatSet.empty eops
  | _ -> failwith "def_of"

let extract_simple_defs' : cfg -> Node.t -> var BatSet.t
= fun cfg node ->
  let stmt = find_stmt node cfg in
  match stmt with
  | Assign (lv,e,_) when def_simple e -> def_of lv
  | _ -> BatSet.empty

let extract_simple_defs : cfg -> Node.t list -> var BatSet.t
= fun cfg nodes ->
  List.fold_left (fun acc n ->
    BatSet.union (extract_simple_defs' cfg n) acc
  ) BatSet.empty nodes

let extract_other_defs' : cfg -> Node.t -> var BatSet.t
= fun cfg node ->
  let stmt = find_stmt node cfg in
  match stmt with
  | Assign (lv,e,_) when def_other e -> def_of lv
  | _ -> BatSet.empty

let extract_other_defs : cfg -> Node.t list -> var BatSet.t
= fun cfg nodes ->
  List.fold_left (fun acc n ->
    BatSet.union (extract_other_defs' cfg n) acc
  ) BatSet.empty nodes

let extract_simple_other_defs : Global.t -> Path.t list -> var BatSet.t * var BatSet.t
= fun global hist_paths ->
  let hist_paths = List.tl hist_paths in (* exclude constructor path *)
  List.fold_left (fun (acc_simple, acc_other) path ->
    let (fk,nodes) = (Path.get_fkey path, Path.get_bp path) in
    let cfg = Lang.get_cfg (FuncMap.find fk global.fmap) in
    let new_simple = extract_simple_defs cfg nodes in
    let new_other = extract_other_defs cfg nodes in
    (BatSet.union new_simple acc_simple, BatSet.union new_other acc_other)
  ) (BatSet.empty, BatSet.empty) hist_paths

let extract : Global.t -> var BatSet.t -> var BatSet.t -> cfg -> Node.t -> feature -> feature
= fun global simple_defs other_defs cfg node feat ->
  let stmt = find_stmt node cfg in
  match stmt with
  | Assign (lv,e,_) ->
    feat
    |> (if def_simple e then add_def_simple else id)
    |> (if def_other e then add_def_other else id)
  | Assume (e,_) ->
    feat
    |> (if use_simple e then add_use_simple else id)
    |> (if use_other e then add_use_other else id)
    |> (if use_of_prev_def_simple simple_defs e then add_use_of_prev_def_simple else id)
    |> (if use_of_prev_def_other other_defs e then add_use_of_prev_def_other else id)
  | _ -> feat


(* transform path into feature vector *)
let feature_map : Global.t -> Path.t list -> Path.t -> feature
= fun global hist path ->
  let (fk,nodes) = (Path.get_fkey path, Path.get_bp path) in
  let func = FuncMap.find fk global.fmap in
  let cfg = Lang.get_cfg (FuncMap.find fk global.fmap) in
  let feat =
    empty_feature
    |> (if invoked_before hist path then add_invoked_before else id)
    |> (if is_payable func then add_def_other else id)
  in
  let (simple_defs, other_defs) = extract_simple_other_defs global hist in
  List.fold_left (fun acc n ->
    extract global simple_defs other_defs cfg n acc
  ) feat nodes


(***************************)
(*** Word representation ***)
(***************************)

type word = S | C | F of feature | OOV
and dict = string BatSet.t

let to_string_word : word -> string
= fun word ->
  match word with
  | S -> "<S>"
  | C -> "[C]"
  | F feat -> string_of_feature feat
  | OOV -> "[OOV]"

let to_string_sentence : word list -> string
= fun words -> string_of_list ~first:"" ~last:"" ~sep:"-" to_string_word words

let word_map : Global.t -> Transaction.t list -> Transaction.t -> word
= fun global hist tx ->
  let hist_path = List.map Transaction.get_path hist in
  let cur_path = Transaction.get_path tx in
  let func = FuncMap.find (Path.get_fkey cur_path) global.fmap in
  if is_constructor func then C
  else
    let feat_vec = feature_map global hist_path cur_path in
    F feat_vec

let word_seq_map : Global.t -> Transaction.t list -> word list
= fun global txs ->
  let (words,_) =
    List.fold_left (fun (acc_w,acc_t) tx ->
      let new_w = word_map global acc_t tx in
      (acc_w @ [new_w], acc_t @ [tx])
    ) ([],[]) txs
  in
  words

let is_known_word : dict -> word -> bool
= fun dict word ->
  if BatSet.mem (to_string_word word) dict then true
  else false

let word_map_plus : Global.t -> dict -> Transaction.t list -> Transaction.t -> word
= fun global dict hist tx ->
  let word = word_map global hist tx in
  if is_known_word dict word then word
  else 
    (* let _ = print_endline (Transaction.to_string_transaction_simple global tx) in *)
    (* let _ = print_endline (to_string_word word) in *)
    OOV

let word_seq_map_plus : Global.t -> dict -> Transaction.t list -> word list
= fun global dict txs ->
  let (words,_) =
    List.fold_left (fun (acc_w,acc_t) tx ->
      let new_w = word_map_plus global dict acc_t tx in
      (acc_w @ [new_w], acc_t @ [tx])
    ) ([],[]) txs
  in
  words
